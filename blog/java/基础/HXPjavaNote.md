## 韩顺平java基础笔记

### 时间: 2022/8/16

### Tags: java, 基础



## 第一, 二章:

1. **JDK, JRE和JVM的包含关系:**

   JDK = JRE + 开发工具集(例如java, javac编译工具等)

   JRE = JVM + Java SE 标准类库(java 核心类库)



## 第三章

1. **ctrl + d: **

   复制当前行

2. **char类型进行计算:**

   char中记录的是字符的ASCII码, 进行计算时也是计算字符的码值, 最后输出一个整数

3. **java数据类型:**

   1. 基本数据类型:
      1. 数值型:
         1. 整数类型:
            1. byte 1字节
            2. short 2字节
            3. int 4字节
            4. long 8字节
         2. 小数类型(java中小数都是近似值)
            1. float 4字节
            2. double 8字节
      2. 字符型:
         1. char 2字节 存放单个字符
      3. 布尔型:
         1. boolean 1字节
   2. 引用数据类型:
      1. 类
      2. 接口
      3. 数组

4. **java api查询方法:**

   先查询包, 在查询类, 在查询api

5. **java字符存储原理:**

   1. 'a' -> 码值97 -> 二进制(110 0001) -> 存储
   2. 读取就反过来
   3. 字符和码值的对应关系是通过字符编码表决定的(规定好的)

6. **常用字符编码表:**

   1. ASCII:

      一个字节表示, 表示了128个字符(英语的字符,像字母,英文标点那样的)

   2. Unicode:

      固定大小的编码, 使用两个字节来表示字符, 字母和汉字统一都是占用两个字节

   3. utf-8:

      大小可变的编码, 字母使用1个字节, 汉字使用3个字节

   4. gbk:

      可以表示汉字, 而且范围广, 字母使用1个字节, 汉字2个字节

7. **基本数据类型, 自动类型转换细节:**

   1. 有多种类型的数据混合运算时, 系统首先将所有数据转成容量最大的那种数据类型, 然后在进行计算.
   2. 当我们把容量大的数据类型赋值给容量小的数据类型时,就会报错, 反之就会进行自动类型转换
   3. (byte, short) 和 char之间不会相互自动转换
   4. byte, short char 他们三者可以计算, 在计算时首先转化成int
   5. boolean不参与转换
   6. 自动提升原则: 表达式结果类型自动提升为 操作数中最大的类型

8. **基本数据类型, 强制类型转换细节:**

   1. 使用是要加上强制转换符 ()
   2. 可能造成精度降低或者溢出
   3. 强转符号只针对与最近的操作数有效, 使用小括号括起来, 就可以作用于整个表达式了
   4. char类型可以保存int的常量值(100, 200), 但不能保存int的变量值(int m=100; char i=m;), 需要强转
   5. byte和short, char类型在进行运算时, 当做int类型处理.

   


## 第四章 运算符

## 第五章 循环控制

## 第六章 数组

## 第七章 面向对象基础

1. **成员方法传参机制:**

   1. 基本数据类型:

      值传递, 对原本的参数没有影响.

   2. 引用数据类型:

      引用传递, 传递的是内存地址, 对原本的参数有影响

   3. 

## 第八章 面向对象中级:

1. **idea快捷键:**

   - ```java
     // idea 快捷键:
     // 1 ctrl + d 删除当前行
     // 2 ctrl + alt + 下光标 复制当前行
     // 3 alt + / 自动补全
     // 4 ctrl + / 添加注释或者解除注释
     // 5 alt + enter 自动导入类
     // 6 ctrl + alt + L 自动格式化
     // 7 alt + r 快速运行程序
     // 8 alt + insert 生成构造器等方法
     // 9 ctrl + h (需要将光标放在类名上)查看类的继承关系, 甚至可以生成图表
     // 10 ctrl + b (需要将光标放在方法名上)定位方法, 和ctrl+点击方法名同效
     // 11 new Object().var 自动创建变量
     ```
     
   - ~~~java
     // 模板/自定义模板
     // 1. main 生成main方法
     // 2. sout 打印输出快捷键
     // 3. fori 普通for循环快捷键
     // settings -> editor -> Live templates (查看所有模板配置, 可以自定义模板)
     ~~~

2. **即使子类的构造方法中没有super(), 在创建子类实例时, 也会自动调用父类的无参构造方法.**

   

3. **向上转型和向下转型:**

   ~~~
   向上转型: 
   父类的引用指向子类的对象, 就是编译时为父类类型, 实际运行时为子类类型, 是java多态的体现
   
   这样的好处是实现了参数统一, 调用方法时,只能调用父类方法, 或者子类重写的方法, 不能调用子类独有的方法, (因为编译的时候编译器只认编译类型, 就会去父类中寻找调用的方法, 但是实际运行时, 因为动态绑定, 是从下往上找的,也就是从子类开始向上找的, 找到了就会执行, 所以运行时如果子类重写了父类的方法, 调用的是子类的方法)
   
   向下转型: 
   为了调用子类所独有的方法, 就是将原来父类的引用变成对子类的引用
   就变成了子类的引用指向子类的对象
           
   ~~~

4. == 和 equals的区别:

   | 名称 | 概念 | 用于基本数据类型 | 用于引用数据类型 |
   | ---  | --| -------------| ------------|
   | == | 比较运算符 | 可以, 判断值是否相等 | 可以, 判断内存地址是否相等 |
   | equals | Object类的方法, java类都可以使用equals方法 | 不可以 | 可以, 默认是判断两个内存地址是否相等(和==等效), 但是我们通畅会重写该方法, 用于比较对象的属性是否相等 |

5. **动态绑定:**

   1. 调用对象的方法时, 该方法会和对象的内存地址/运行类型绑定, 就是找方法的时候, 是从运行时类型开始往上找
   2. 当调用对象的属性时, 没有动态绑定机制, 哪里声明, 哪里使用, 就是看编译类型,



## 第九章 房屋出租系统:

1. **分层模式:**
   1. 界面层
   2. 业务层
   3. 数据层

## 第十章 面向对象高级:

1. **类变量(静态变量), 类方法(静态方法), static**:
   1. 静态方法, 只能访问静态成员
   2. 非静态方法, 可以访问所有成员

2. **main方法的语法:**
   1. main方法由java虚拟机调用
   2. java虚拟机要调用类的main方法, 访问权限必须是public, 虚拟机和main方法不在同一个包中
   3. java虚拟机执行main方法时, 不会创建对象, 所以要用static
   4. main方法中的String[] args 是形参列表, 用于在终端中接收输入的参数

3. **代码块:**
   1. 没有方法名, 没有返回, 没有参数, 只有方法体, 修饰符只能选择static, 有静态代码块和非静态代码块, 语法:[修饰符(static)]{方法体}

4. **类只会在第一次调用类之前加载一次:**

   1. 类加载会先加载类中的 静态代码块, 静态变量 的声明. 在执行 非静态代码块 和 非静态变量 的声明.

5. **final关键字:**

   ~~~
   1. 修饰一个引用:
   	如果引用为基本数据类型，则该引用为常量，该值无法修改； 如果引用为引用数据类型，比如对象、数组，则该对象、数组本身可以修改，但指向该对象或数组的地址的引用不能修改。由于成员变量具有默认值，所以用了final之后必须手动赋值，不会再给默认值。final修饰成员变量, 可以直接赋值, 或者在构造器中赋值, 又或者可以在代码块中赋值. 一般直接赋值.
   	
   2. 修饰方法, 方法可以被继承但是不能被重写
   3. 修饰类, 无法被继承
   ~~~

   

6. **抽象类:**

   - ~~~
     1. 抽象类不能用final关键字修饰, final是不能继承的, 而抽象类只有别继承才有意义矛盾了
     
     2. 抽象方法不能用static关键字修饰, 因为static与方法重写无关, static关键字修饰的方法可以被继承但是不能被重写, 矛盾了
     
     3. 抽象方法也不能用private关键字修饰, 私有方法不能重写, 矛盾了
     
     4. 抽象方法, 没有主体, 只需要声明就好了.
     
     5. 抽象类的最佳实践-模板设计模式: 就是将子类中相同的部分, 抽象到一个抽象的父类中, 将这个父类作为一个模板
     
     ~~~

   - 

   

7. **接口:**

   - ~~~
     1. 接口是隐式抽象的, 接口中的方法会被隐式指定为 public abstract, 属性会被隐式指定为 public static final
     2. 接口不能被实例化
     3. 普通类实现接口要实现接口所有的方法, 抽象类实现接口可以不用实现接口的方法
     4. 接口访问形式: 接口名.属性名
     5. 接口不能继承其他的类, 但是可以继承多个别的接口
     6. 接口的修饰符只能是public 和 默认, 这点和类一样
     ~~~

   - 

8. **接口和继承类:**

   - ~~~
     ~~~

   - 

9. 



